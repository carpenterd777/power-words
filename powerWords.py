#!/usr/bin/env python3

from os import system, mkdir
from os import name as os_name
from sys import stderr
from datetime import datetime
from pathlib import Path
import cmd
import argparse
from fpdf import FPDF
from shutil import copyfile

LINE_SPACING = 5
RECOVERY_DIR = Path("./.recovery")

def clear():
    '''Clears the screen. 
    
    Written to work on both Windows and UNIX operating systems.
    '''
    if os_name == 'nt':
        system('cls') # Windows
    else:
        system('clear') # UNIX

def generate_recovery_file() -> Path:
    '''Generates the session recovery file, with no suffix.

    The session recovery file is named after the date and time the
    program is run. It is named in the format:

    yyyy(m)m(d)d_(h)h(i)i(s)s

    where "i" are the digits for the minutes and any digits
    in parentheses are only present when the value has a 
    tens digit.

    :returns: A tuple of Paths representing the recovery 
    directory and recovery text file for one session, 
    respectively.
    '''

    current_time = datetime.now()
    session_recovery_path = Path("{0}{1}{2}_{3}{4}{5}".format(
        current_time.year, 
        current_time.month, 
        current_time.day,
        current_time.hour,
        current_time.minute,
        current_time.second
        ))
    mkdir(RECOVERY_DIR / session_recovery_path)

    return (RECOVERY_DIR / session_recovery_path,
    RECOVERY_DIR / session_recovery_path / session_recovery_path)


SESSION_RECOVERY_DIR, RECOVERY_FILE = generate_recovery_file()


def doc_write(string: str, pdf: FPDF, file_name: Path, *, newlines: int = 2):
    '''Writes the text to the PDF file and log reading file.


    :param string: Text to be written to the PDF file.   
    :param pdf: The PDF file object to be written to.  
    :param file_name: The name of the file.
    '''

    pdf.set_font('Arial', size = 12)
    pdf.write(LINE_SPACING, string)

    #recovery
    with file_name.with_suffix('.txt').open('a') as f:
        f.write(("\n" * newlines) + (string))

def doc_image(image_path: Path, pdf: FPDF, file_name: Path):
    '''Adds the image to the document and a string to the log
    indicating the image added.

    :param image_path: The path to which the image is located.  
    :param pdf: The PDF file object to be written to.  
    :param file_name: The name of the file.  
    '''

    pdf.write(LINE_SPACING, '\n')
    pdf.image(str(image_path), w = 50)

    #recovery
    recovery_image_path = SESSION_RECOVERY_DIR / image_path.name
    with file_name.with_suffix('.txt').open('a') as f:
        f.write('\n\n!image ./' + image_path.name)
    copyfile(image_path, recovery_image_path)
    

def session_number_prompt() -> int:
    '''Prompts the user for the session number until a valid one
    is entered. 
    
    :returns: The input session number.'''

    session_number = None
    while type(session_number) != int:
        session_number = input("Session number: ")
        try:
            session_number = int(session_number)
        except ValueError:
            print("That is not a valid session number.", file=stderr)
            continue

    return session_number

def session_title_prompt() -> str:
    '''Prompts the user for the session title.

    The session title that is prompted from the user will be
    used to name the file that is generated by the program.
    
    :returns: The session title.
    '''

    session_title = ''
    while session_title == '':
        session_title = input("Session title: ")
    
    return session_title

def attach_time_to_note(note: str) -> str:
    '''Affixes a timestamp to the input.
    
    :param note: A string.  
    :returns: A string with a timestamp affixed to the front.
    '''

    time = datetime.now().strftime('%I:%M %p')

    return time + " " + note

def init_file(file_name: Path, session_title: str, session_number: int) -> FPDF:
    '''Generates the document file and data recovery log.
    
    :param file_name: The name of the file.  
    :param session_title: The user input session title.  
    :param session_number: The user input session number.  
    :returns: A CustomPDF object initalized with a header.
    '''

    date_string = datetime.now().strftime("%m-%d-%Y")

    pdf = CustomPDF(orientation='P', unit='mm', format='A4')
    pdf.set_title("Session " + str(session_number) + ": " + session_title + " - " + date_string)
    pdf.set_font('Arial', size = 12)
    pdf.add_page()
    with file_name.with_suffix('.txt').open('a') as f:
        f.write("Session " + str(session_number) + ": " + session_title + " - " + date_string)
    
    return pdf

def check_path(path: str) -> Path:
    '''Checks if path is valid.

    :param path: A filepath.  
    :returns: The valid Path object.  
    :raises: argparse.ArgumentTypeError: when log file is missing or the file path
    is invalid.
    '''
    p = Path(path)
    if p.exists() and p.suffix == '.pdf':
        #TODO check the tmp directory for the txt recovery file
        return p
    else:
        raise argparse.ArgumentTypeError('This is not a valid file path.')

def get_options():
    '''Gets the options that the user inputs when
    launching the program.
    
    :returns: The options.
    '''
    parser = argparse.ArgumentParser()
    parser.add_argument('--file', '-f', action='store', type=check_path)
    options = parser.parse_args()
    return options

def rewrite_doc(file_name: Path) -> FPDF:
    '''Creates a CustomPDF object with all the logs
    from the log file rewritten onto it.

    This function is necessary because the CustomPDF object does
    not allow further writes to be made once the output file has been generated.

    :param fname: The name of the recovery text file.
    :returns: The rewritten PDF object.
    '''

    pdf = CustomPDF(orientation='P', unit='mm', format='A4')

    pdf.set_font('Arial', size = 12)

    with file_name.open() as f:
        lines = f.readlines()
        pdf.set_title(lines[0])
        pdf.add_page()
        for line in lines[1:]:
            if line[0:6] == '!image':
                image_path = line.split(' ')[1]
                if Path(image_path).exists():
                    pdf.write(LINE_SPACING, '\n')
                    pdf.image(image_path, w=50)
            else:  
                pdf.write(LINE_SPACING, line)
    
    return pdf

class CustomPDF(FPDF):
    '''A PDF with a custom header.'''

    def header(self):
        # Arial bold 15
        self.set_font('Arial', 'B', 15)
        # Calculate width of title and position
        w = self.get_string_width(self.title) + 6
        self.set_x((210 - w) / 2)
        # Colors of frame, background and text
        self.set_draw_color(255, 255, 255)
        self.set_fill_color(255, 255, 255)
        # self.set_text_color(31, 3, 1)
        # Title
        self.cell(w, 9, self.title, 1, 1, 'C', 1)
        # Line break
        self.ln(10)

class PowerWords(cmd.Cmd):
    '''The primary framework to build the command
    line application.
    '''
    
    intro = "powerWords v1.0\n"
    prompt = "PowerWords> "

    def preloop(self):
        '''Initialization before the main program loop.'''
        clear()
        options = get_options()

        #initialize object members
        if not options.file:
            self.session_title = session_title_prompt()
            self.session_number = session_number_prompt()
            self.file_name = Path('_'.join(self.session_title.lower().split(' ')) + '.pdf')
            self.pdf = init_file(RECOVERY_FILE, self.session_title, self.session_number)
        else:
            self.file_name = Path(options.file + '.pdf')
            self.pdf = rewrite_doc(str(self.file_name))
        self.previous_time = None
        clear()

        #create recovery directory if it doesnt exist
        if not RECOVERY_DIR.exists():
            mkdir(RECOVERY_DIR)
        
    def do_image(self, arg_string):
        '''Adds an image to the document.
        
        :param arg_string: A user input image file path.
        '''
        
        #validation
        p = Path(arg_string)
        if not p.exists():
            print("That file could not be found.", file=stderr)
            return
        elif p.suffix not in ['.jpg', '.png']:
            print("That file is not an image.", file=stderr)
            return
    
        doc_image(p, self.pdf, RECOVERY_FILE)
    
    def do_quit(self, arg_string):
        '''Outputs the notes and exits the application.'''
        self.pdf.output(str(self.file_name))
        return True
    
    def default(self, arg_string):
        '''Appends a note to the log file.
        
        :param arg_string: The note to be appended.
        '''
        self.current_time = datetime.now().strftime('%I:%M %p')

        if self.current_time == self.previous_time:
            doc_write(arg_string, self.pdf, RECOVERY_FILE, newlines=1)
        else:
            timed_arg_string = attach_time_to_note(arg_string)
            doc_write(timed_arg_string, self.pdf, RECOVERY_FILE)

        self.previous_time = self.current_time

if __name__ == '__main__': PowerWords().cmdloop()
